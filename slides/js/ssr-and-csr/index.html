<!DOCTYPE html>
<html lang="en">

<head>
  <title>Rendering</title>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="shower/themes/ribbon/styles/screen-16x10.css">
  <link rel="stylesheet" href="style.css">
</head>

<body class="shower list">

<section class="slide intro">
</section>

<section class="slide">
  <h2>Немного истории</h2>
  <p>С начала времен стандартным подходом подготовки html для просмотра пользователем был рендер на стороне сервера. Мы
    закидывали на сервер html страницы, а он раздавал их браузеру как html документы. В те времена рендер на стороне
    сервера работал отлично. Большинство сайтов были наборами статического текста и картинок, с минимальной
    интерактивностью.</p>
  <p>В совремнном вебе все не так, слово сайт осталось как дань прошлому, теперь каждый 'сайт' это веб-приложение
    которое маскируется под сайт. Мы покупаем, продаем, проверяем сообщения, общаемся в чатах итд, и все это на
    'сайтах'. Колличество двигающихся шестеренок на современном 'сайте', за которыми нужно следить разработчику, у
    новичка может вызвать приступ панического страха, не без оснований.</p>
  <p>Именно из-за сдвига в сторону полной интерактивности, рендер на стороне клиента становится все более популярен.
    Почему? Какой метод все-таки лучше? Так же как и с большинством решений при разработке - зависит от задачи и
    желаемого результата.</p>
</section>

<section class="slide text-small">
  <h2>Server-side rendering</h2>
  <p>Когда мы заходим на сайт, браузер посылает запрос серверу на котором находятся ресурсы веб страницы. В большинстве
    случаев этот запрос очень быстрый, но на скорость могут влиять следующие факторы: </p>
  <ul>
    <li>ваша скорость подключения к интернету</li>
    <li>место на сервере где хранятся ресурсы</li>
    <li>сколько пользователей в данный момент тоже хотят получить эти данные</li>
    <li>и конечно насколько оптимизирован сайт</li>
  </ul>
  <p>Когда запрос был обработан сервером, ваш браузер получет полностью готовый html и отображает его. Когда вы решите
    перейти на другую страницу на этом сайте, браузер опять создаст запрос на сервер, но уже на другие ресурсы. Так
    будет происходить каждый раз когда вы посещаете новую страницу которой нету в кеше браузера.</p>
  <p>И не важно что на новая страница отличается от предыдущей всего одним елементом, браузер попросит у сервера
    страницу полностью,и так каждый раз...</p>
</section>

<section class="slide text-small ssr">
  <h2>SSR in details</h2>
  <div class="content">
    <div>
      <p>Первая страница, рут <i>example.testsite.com.</i> Если бы мы ввели <i>example.testsite.com</i> в адресную
        строку, то наш
        браузер послал бы запрос на сервер и ожидал ответа. Результатом был бы документ. В этом случае у нас визуально
        отобразится заголовок, параграф и ссылка.</p>
      <img src="pictures/ssr-1.jpg" alt="">
    </div>
    <div>
      <p>Вторая страница. Разница только в том что нету ссылки, вместо нее еще один параграф. Логично подумать что нам
        необходимо визуально заменить только ссылку на параграф и все ок. К сожалению SSR так не работает. Что произошло
        бы - полная перезагрузка страницы и отображение результата запроса на
        сервер, новая веб страница.</p>
      <img src="pictures/ssr-2.jpg" alt="">
    </div>
  </div>
</section>

<section class="slide">
  <h2>Client-side rendering</h2>
  <p>Когда мы говорим рендер на стороне клиента, имеется ввиду рендер контента в окне браузера используя JavaScript.
    Вместо того чтобы получить полностью готовый html документ, мы получаем bootstrap html документ и файл JavaScript
    который будет рендерить содержимое документа используя сам браузер.</p>
  <p>Таким образом за содержимое веб страницы в браузере отвечает не сервер, а клиент. Что позволяет использовать
    современные подходы при разработке веб-приложений.</p>
  <p>Этот подход относительно новый. Он стал популярен когда появились JavaScript библиотеки несущие в себе необходимый
    функционал. К примеру React.js и Vue.js, а так же многие другие.</p>
</section>
<section class="slide csr text-tiny">
  <h2>CSR in details</h2>
  <p>С первого взгляда можно увидеть координальные изменения в html документе. Вместо привычного контента внутри html
    файла, у нас div-контейнер с идентификатором root. Плюс набор тегов script перед закрывающим тегом body. В нашем
    примере один подгрузит файл библиотеки Vue.js, второй подгрузит файл app.js в котором содержится логика
    приложения.</p>
  <p>Это координально отличается от рендера на стороне сервера, потому что теперь сервер отвечает только за загрузку
    минимального набора ресурсов необходимых для 'старта приложения' и обращения к базе данных по закросу клиента. Все
    остальное ложится на плечи библиотеки JavaScript, в нашем случае Vue.js, которая и будет отвечать за рендер на
    стороне клиента, и кастомного кода написаного вами в файле app.js.</p>
  <img src="pictures/csr-1.jpg" alt="">
</section>
<section class="slide">
  <h2>SEO</h2>
  <h3>SSR</h3>
  <p>Рендер на стороне сервера очень хорош для SEO. Контент страницы доступен до того как мы его получим, поэтому
    поисковики могут хорошо индексировать такие страницы.</p>
  <h3>CSR</h3>
  <p>Контент не рендерится до того момента пока веб-страница не загрузится в браузере. Это ударит по SEO, поисковикам
    будет тяжелее индексировать такие страницы. Есть специальные методы борьбы с этой проблемой.</p>
  <p>Так же стоит помнить что ваше приложение не сможет исполнится до полной загрузки всего JavaScript. Если у ваших
    юзеров плохое подключение к интернету, это может начальную загрузку страницы продолжительной(секунды), зато потом
    все будет молниеносно быстро.</p>
</section>
<section class="slide text-small">
  <h2>Pros and Cons</h2>
  <ul class="double">
    <li>SSR pros:
      <ol>
        <li>Поисковые роботы могут лучше индексировать страницы.</li>
        <li>Первая загрузка страницы быстрее.</li>
        <li>Хорошо подхоит для статических сайтов с минимальной интерактивностью.</li>
      </ol>
    </li>
    <li>SSR cons:
      <ol>
        <li>Частые запросы на сервер.</li>
        <li>Низкое время загрузки страницы.</li>
        <li>Полная перезагрузка страниц как реакция на действия пользователя.</li>
        <li>Плохое решение для веб-приложений с высоким уровнем интерактивности.</li>
      </ol>
    </li>
    <li>CSR pros:
      <ol>
        <li>Отлично подходит для интерактивных интерфейсов.</li>
        <li>Молниеносный рендер страницы после первой загрузки.</li>
        <li>Хорошее решение для веб-приложений.</li>
        <li>Большой выбор хорошо зарекомендовавших себя JavaScript библиотек.</li>
      </ol>
    </li>
    <li>CSR cons:
      <ol>
        <li>Плохая поддрежка SEO, если сдело без использования подходов оптимизации.</li>
        <li>Первая загрузка может занять больше времени чем SSR.</li>
        <li>В большинстве случаев требует использование внешней библиотеки.</li>
      </ol>
    </li>
  </ul>
</section>

<section class="slide ssr-react">
</section>

<section class="slide csr-react">
</section>

<div class="progress"></div>

<script src="shower/shower.min.js"></script>
</body>

</html>
